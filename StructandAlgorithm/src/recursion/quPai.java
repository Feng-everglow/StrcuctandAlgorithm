package recursion;

/**
 * @author admin
 * @version 1.0.0
 * @ClassName quPai.java
 * @Description
 * 给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，
 * 但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。
 * 请返回最后获胜者的分数。
 * 【举例】arr=[1,2,100,4]。开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2,100,4]，
 * 接下来玩家B可以拿走2或4，然后继续轮到玩家A...如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，
 * 然后继续轮到玩家A...玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排列变为[2,100,4]，
 * 接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。arr=[1,100,2]。开始时，玩家A不管拿1还是2，
 * 玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回10
 * @createTime 2021年03月18日 15:47:00
 */
public class quPai {
    //先手 在【i.j】范围上返回经过先手能得到的最大分数
    public static int first(int[] arr,int i,int j){
        if (i==j){ //basecase
            return arr[i]; //先手，剩一张牌，只能拿
        }
        //只能取两边，取i后，剩下的【i+1,j】范围，第二次取数（第二次可以看做后手）或者，取j后，剩下的【i,j-1】范围，第二次取数
        //如何对先手的人有利，那就是取最大
        return Math.max(arr[i]+second(arr,i+1,j),arr[j]+second(arr,i,j-1));
    }

    //后手 返回经过后手后，在【i.j】范围上能得到的最大分数
    private static int second(int[] arr, int i, int j) {
        if (i==j){ //basecase 后手，只有一个数，那会被先手拿走，所以只能得到0
            return 0;
        }
        //如果别人先拿走i，我只能在【i+1,j】范围上轮到我先手
        // 如果别人先拿走j，我只能在【i,j-1】范围上轮到我先手
        //如何对后手的人有利，这里逆向思维，后手只有通过先手的结果确定，所以是动态的，两人敌对又聪明，分数越高越好
        //那么，作为后手的最大分数是被人决定的（先手的那个人），别人只会把最差情况给我，所以我要把最差情况最小化
        return Math.min(first(arr, i + 1, j), first(arr, i, j - 1));

    }
    //判断赢家（法1）
    public static int win1(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        //玩家1在【0，n-1】范围上先手，                         玩家2在【0，n-1】范围上后手
        //谁得分大谁赢
        return Math.max(first(arr, 0, arr.length - 1), second(arr, 0, arr.length - 1));
    }
/*动态规划解法
用F[l][r]表示先选的人能拿到的最高分
用S[l][r]来表示后选的人能拿到的最高分
如对于一组从0,1,2，...,n-1的数
对于先选者，他有两种选法
若先选者选A[0],则对于后面的1，...,n-1数组，他就变成了后选者，此时能拿到的分为A[0]+S[1][n-1]
若先选者选A[n-1],则对于前面的数组0，...，n-2,同样变为后选者，此时能拿到得分为A[n-1]+S[0][n-2];
所以 F[0][n-1]=max(A[0]+S[1][n-1],A[n-1]+S[0][n-2])
对于后选者，他能能到的最高分是受先选者控制的，即他只能选到先选者留给他的最小值，将其转化为数学形式就是
S[l][r]=min(F[l+1][r],F[l][r-1]);
这里的最小值是先选者留给他的，他只能拿到最小值，打个比方，我是先选者，我若选A[0]，剩下的留给你选，这个时候主动权在你
所以你能得到的最大分必为F[1][n-1],我若选A[n-1]，剩下的留给你选，这个时候主动权在你
所以你能得到的分必为F[0][n-2],我肯定是要把能得到的分少的那个留给你，所以你只能得到Min(F[1][n-1],F[0][n-2]);
为什么取较小值，而不是较大值？因为a和b都是绝顶聪明人，你是在另一个绝顶聪明人之后才拿的，他给你剩下的肯定是较坏的情况
*/

    //判断赢家 （法2 DP）
    public static int win2(int[] arr, int n) {
        // f[i][j]表示在牌[i...j]下，先选能获得的最大分数
        // s[i][j]表示在牌[i...j]下，后选能获得的最大分数
        // 如，f[3][6]表示剩余待取卡片范围是3到6时，此刻的先选者能获得的分数
        int[][] f = new int[n][n];
        int[][] s = new int[n][n];
        for (int j = 0; j < n; j++) {
             // 当有 j+1 张卡片的时候，可以计算出：
            // 剩下只有第 j 张卡片时的情况，
            // 剩下第 j-1 到第 j 张卡片时的情况，
            // 剩下第 j-2 到第 j 张卡片时的情况，
            // ......
            // 剩下第 0 到第 j 张卡片时的情况。
            // s[j][j] = 0; // 只有一张卡片时，后选者s[j][j] = 0；
            f[j][j] = arr[j]; // 只有一张卡片时，先选者直接赋值即可。
            for (int i = j - 1; i >= 0; i--) {
                // 计算第 i 到第 j 张卡片时的情况，i = {j-1, j-2, ..., 0}
                // 计算先选者：
                // 本次选择完成后，在下次选择中变为后选者。
                // 分别判断选择最左和最右时的情况，使本次选择最优。
                // 选择最左第 i 张时，那下次就是第 i+1 到第 j 张卡片的后选者。
                // 选择最右第 j 张时，那下次就是第 i 到第 j+1 张卡片的后选者。
                // 比较两种选择方式，找到最优的结果。
                // 有两种拿法：1.先手拿最左边的。那么下一次拿的时候只能后选 2.先手拿最右边的。那么下一次拿的时候只能先选
                f[i][j] = Math.max(arr[i] + s[i + 1][j], arr[j] + s[i][j - 1]);
                // 计算后选者：
                // 本次先选者选完后，由本次的后选者选下一张牌，后选者是下一次的先选者。
                // 后选者本次不是实际进行拿牌，实际拿牌是下次以先选者的身份，所以计算后选者不用加上A[i]或A[j]。
                // 双方都很聪明，使后选者只能获取较小的分数。
                // 即，因为本次先选者的选择，使得后选者只能选择结果较小的分数
                s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]); // 后手只能获得较小的分数（双方都很聪明，后选当然只能获得较少的分数）
            }
        }
        return Math.max(f[0][n - 1], s[0][n - 1]);
    }
    public static void main(String[] args) {
        int[] arr = { 1, 9, 1 };
        System.out.println(win1(arr));
        System.out.println(win2(arr,3));
    }
}
